#
#********************************************************************************
#** Module        : modbusstrings.pl
#** Originator    : Mark Roberts
#** Creation Date : 1st October, 1998
#**
#** Code Review Reference : <the code review form number>
#**
#** (c) 1998 GEC ALSTHOM T&D P&C Ltd.
#** (c) 1998 GEC ALSTHOM T&D P&C SA.
#********************************************************************************
#

#------------------------------------------------------------------------------
#  DOCUMENTATION
#
# This PERL script is used to extract language information and enumeration
# names from the language text .dfn files. It then uses a file of ModBus
# address to enumeration name mappings to generate a list of language
# strings related to ModBus addresses. These strings may then be used by the
# ModBus master station.
#  ----------------------------------------------------------------------------

#------------------------------------------------------------------------------
#  INCLUDE FILES
#------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  CONSTANTS
#-------------------------------------------------------------------------------
$Title = "MODBUSSTRINGS PERL SCRIPT\n";
$HelpText = $Title." Command line argument information :\n".
                   "  /D=Definition file (.dfn) There may be any number of definition files.\n".
                   "  /L1=language one { e.g. English }\n".
                   "  /L2=language two { e.g. French }\n".
                   "  /L3=language three { e.g. German }\n".
                   "  /L4=language four { e.g. Spanish }\n".
                   "  /M=ModBus address to enum mapping file.\n".
                   "  /O= output file name\n";
$FileHeader = "/* This file has been automatically generated by the PERL script\n".
              " * /50300PL/DEV/util/src/langsplit.pl.\n *\n".
              " *                    DO NOT EDIT THIS FILE !!\n *\n".
              " * Modifications should be carried out by changing the definition\n".              " * files used to create the file. Use the ClearCase configuration\n".
              " * record to locate the source data definition files. \n */\n\n";

$BSlash = chr(92);
$LanguagesToProcess = 4;
#-------------------------------------------------------------------------------
#  PUBLIC VARIABLES
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  SUBROUTINES
#-------------------------------------------------------------------------------
    sub ReadDefinitionFile;
#-------------------------------------------------------------------------------
#  Main function
#-------------------------------------------------------------------------------

    #---------------------------------------------------------------------------
    # Process command line arguments.
    #---------------------------------------------------------------------------

    for($Counter = 0; $Counter <= $#ARGV; $Counter++)
    {
        $_ = $ARGV[$Counter];

        if (m|/D|)
        {
            ReadDefinitionFile($ARGV[$Counter]);
        }
        elsif (m|/L1|)
        {
            $LanguageOneName = $ARGV[$Counter];
            $LanguageOneName =~ s|/L1=||;
        }
        elsif (m|/L2|)
        {
            $LanguageTwoName = $ARGV[$Counter];
            $LanguageTwoName =~ s|/L2=||;
        }
        elsif (m|/L3|)
        {
            $LanguageThreeName = $ARGV[$Counter];
            $LanguageThreeName =~ s|/L3=||;
        }
        elsif (m|/L4|)
        {
            $LanguageFourName = $ARGV[$Counter];
            $LanguageFourName =~ s|/L4=||;
        }
        elsif (m|/O|)
        {
            $OutputFile = $ARGV[$Counter];
            $OutputFile =~ s|/O=||;
        }
        elsif (m|/M|)
        {
            ReadMappingFile($ARGV[$Counter]);
        }
        elsif (m|/?|)
        {
            # Display help
            print $HelpText;

        }
        else
        {
            print "ARGUMENT ERROR \n";
        }
    }

    #---------------------------------------------------------------------------
    # Split the definition data into individual lines.
    #---------------------------------------------------------------------------

    @SplitRes = split /\n/, $DefinitionData;

    # For each line split into the components.

    @SplitLines = @SplitRes;

    foreach $SingleLine (@SplitLines)
    {
        $_ = $SingleLine;

        if (m/^#/)
        {
            # # directive line which should not be here. Produce an error message
            # because to continue and include everything may produce undesired results
            # due to the failure of the user to process the file using the 'C' preprocessor.
            #
            print ("\n ERROR : # found at the start of a line which indicates that\n");
            print ("         the file should be processed by the 'C' pre-processor.\n");
            print ("         Note that comments in the file should use the c++ style of\n");
            print ("         // at the start of every comment line.\n");
            exit(-1);
        }
        elsif (m/\/\//)
        {
            # Comment line to be ignored.
        }
        else
        {
            # Remove spaces except those in the string text.

            $QuoteFound = 0;

            @SplitRes = split //, $SingleLine;

            $SpaceFreeLine = "";

            if (@SplitRes > 0)
            {
                foreach $char (@SplitRes)
                {
                    $_ = $char;

                    if (m/ /)
                    {
                        if ($QuoteFound == 1)
                        {
                            $SpaceFreeLine = $SpaceFreeLine.$char;
                        }
                    }
                    elsif (m/\"/)
                    {
                        $SpaceFreeLine = $SpaceFreeLine.$char;
                        if ($QuoteFound == 1)
                        {
                            $QuoteFound = 0;
                        }
                        else
                        {
                            $QuoteFound = 1;
                        }
                    }
                    else
                    {
                        $SpaceFreeLine = $SpaceFreeLine.$char;
                    }
                    $Counter++;
                }

                @SplitRes = split /,/, $SpaceFreeLine;

                push @DefineList, $SplitRes[0];

                if (length($SplitRes[0]) > $MaxDefineLength)
                {
                    $MaxDefineLength = length($SplitRes[0]);
                }

                for ($LanguageCounter = 0; $LanguageCounter < 4; $LanguageCounter++)
                {
                    if ($LanguageCounter == 0)
                    {
                        push @LanguageOneList, $SplitRes[1 + $LanguageCounter];
                    }
                    if ($LanguageCounter == 1)
                    {
                        if ($LanguagesToProcess > 1)
                        {
                            push @LanguageTwoList, $SplitRes[1 + $LanguageCounter];
                        }
                     	else
                     	{
                     		push @LanguageTwoList, $SplitRes[1];
	                    }
                    }
                    elsif ($LanguageCounter == 2)
                    {
                        if ($LanguagesToProcess > 2)
                        {
                            push @LanguageThreeList, $SplitRes[1 + $LanguageCounter];
                        }
                     	else
                     	{
                     		push @LanguageThreeList, $SplitRes[1];
	                    }                    }
                    if ($LanguageCounter == 3)
                    {
                        if ($LanguagesToProcess > 3)
                        {
                            push @LanguageFourList, $SplitRes[1 + $LanguageCounter];
                        }
                     	else
                     	{
                     		push @LanguageFourList, $SplitRes[1];
	                    }
	              	}
                }

                push @StringTableNameList, $SplitRes[1 + $LanguagesToProcess];

                if (length($SplitRes[1 + $LanguagesToProcess]) > $MaxStringTableNameLength)
                {
                    $MaxStringTableNameLength = length($SplitRes[1 + $LanguagesToProcess]);
                }
            }
        }
    }

    #---------------------------------------------------------------------------
    # Split mapping data.
    #---------------------------------------------------------------------------

    @SplitRes = split /\n/, $MappingData;

    # For each line split into the components.

    @SplitLines = @SplitRes;

    foreach $SingleLine (@SplitLines)
    {
        @SplitParts = split /:/, $SingleLine;

        $ModBusAddress = $SplitParts[0];

        $ModBusAddress =~ s/ //g;

        $EnumName = $SplitParts[1];

        $EnumName =~ s/ //g;

        push @ModBusAddressList, $ModBusAddress;
        push @ModBusEnumName, $EnumName;
    }

    #---------------------------------------------------------------------------
    # Check that each enumeration listed in the mapping file has an entry in the
    # definition data.
    #---------------------------------------------------------------------------

    foreach $EnumName (@ModBusEnumName)
    {
        $Found = 0;

        foreach $StringName (@StringTableNameList)
        {
            if (($EnumName cmp $StringName) == 0)
            {
                $Found = 1;
            }
        }
        if ($Found == 0)
        {
            print "The enumerated string ".$EnumName." was not found in the definition data.\n";
            exit(-1);
        }
    }

    #---------------------------------------------------------------------------
    # Get the longest item in each list.
    #---------------------------------------------------------------------------

    $LanguageOneListMax = 0;

    foreach $Lang (@LanguageOneList)
    {
        if (length($Lang) > $LanguageOneListMax)
        {
            $LanguageOneListMax = length($Lang);
        }
    }

    $LanguageTwoListMax = 0;

    foreach $Lang (@LanguageTwoList)
    {
        if (length($Lang) > $LanguageTwoListMax)
        {
            $LanguageTwoListMax = length($Lang);
        }
    }

    $LanguageThreeListMax = 0;

    foreach $Lang (@LanguageThreeList)
    {
        if (length($Lang) > $LanguageThreeListMax)
        {
            $LanguageThreeListMax = length($Lang);
        }
    }


    $LanguageFourListMax = 0;

    foreach $Lang (@LanguageFourList)
    {
        if (length($Lang) > $LanguageFourListMax)
        {
            $LanguageFourListMax = length($Lang);
        }
    }


    #---------------------------------------------------------------------------
    # Build the string information.
    #---------------------------------------------------------------------------


    $OutputFile = ">".$OutputFile;

    open OutputFileHandle, $OutputFile;

    print OutputFileHandle "\"".$LanguageOneName."\", ";
    print OutputFileHandle "\"".$LanguageTwoName."\", ";
    print OutputFileHandle "\"".$LanguageThreeName."\", ";
    print OutputFileHandle "\"".$LanguageFourName."\"\n";



    $Index1 = 0;

    foreach $EnumName (@ModBusEnumName)
    {
        $Found = 0;

        $Index2 = 0;

        foreach $StringName (@StringTableNameList)
        {
            if (($EnumName cmp $StringName) == 0)
            {
                $NewLine = @ModBusAddressList[$Index1]. " : ";
                $NewLine = $NewLine.@LanguageOneList[$Index2].",";

                $TargetLength = $LanguageOneListMax + 10;

                while (length($NewLine) <= $TargetLength)
                {
                    $NewLine = $NewLine." ";
                }

                $NewLine = $NewLine.@LanguageTwoList[$Index2].",";

                $TargetLength = $TargetLength + $LanguageTwoListMax + 2;

                while (length($NewLine) <= $TargetLength)
                {
                    $NewLine = $NewLine." ";
                }

                $NewLine = $NewLine.@LanguageThreeList[$Index2].",";

                $TargetLength = $TargetLength + $LanguageThreeListMax + 2;

                while (length($NewLine) <= $TargetLength)
                {
                    $NewLine = $NewLine." ";
                }

                $NewLine = $NewLine.@LanguageFourList[$Index2]."\n";

                print OutputFileHandle $NewLine;

                $Index2++;

            }
            else
            {
                $Index2++;
            }
        }
        $Index1++;
    }

    close OutputFileHandle;

    exit(0);

sub ReadDefinitionFile
{
    my $FileName = shift;

    $FileName =~ s|/D=||;

    open InputFileHandle, $FileName;

    while (eof(InputFileHandle) == 0)
    {
        read InputFileHandle, $DataFromFile, 25;
        $DefinitionData = join('',$DefinitionData, $DataFromFile);
    }

    close InputFileHandle;
}

sub ReadMappingFile
{
    my $FileName = shift;

    $FileName =~ s|/M=||;

    open InputFileHandle, $FileName;

    while (eof(InputFileHandle) == 0)
    {
        read InputFileHandle, $DataFromFile, 25;
        $MappingData = join('',$MappingData, $DataFromFile);
    }

    close InputFileHandle;
}

#
#********************************************************************************
#** END OF FILE
#********************************************************************************
#

