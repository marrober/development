#
#********************************************************************************
#** Module        : langsplit.pl
#** Originator    : Mark Roberts
#** Creation Date : 7th April, 1998
#**
#** Code Review Reference : <the code review form number>
#**
#** (c) 1998 GEC ALSTHOM T&D P&C Ltd.
#** (c) 1998 GEC ALSTHOM T&D P&C SA.
#********************************************************************************
#

#------------------------------------------------------------------------------
#  DOCUMENTATION
#
#  This PERL script is used to convert language text definition files into
#  string tables. See the document /50300PL/doc/dbapp/dblayout.doc  for
#  more information.
#
#  ----------------------------------------------------------------------------

#------------------------------------------------------------------------------
#  INCLUDE FILES
#------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  CONSTANTS
#-------------------------------------------------------------------------------
$Title = "LANGSPLIT PERL SCRIPT\n";
$HelpText = $Title." Command line argument information :\n".
                   "  /D=Definition file (.dfn) There may be any number of definition files.\n".
                   "  /H=Header file name (.h)  File to be produced.\n".
                   "  /S=Source file name (.c)  File to be produced.\n".
                   "  /LANGS = {1|4}            The number of columns of languages in the\n".
                   "                            definition files. Note that if one language is\n".
                   "                            used the 16th character position of languages\n".
                   "                            2, 3 and 4 is replaced with the letter F, G and S\n".
                   "                            to simulate four different languages. This feature\n".
                   "                            is intended for test use only.\n".
                   "  /O1 = lang file (*.txt)   The file to contain the 1st column of text.\n".
                   "  /O2 = lang file (*.txt)   The file to contain the 2nd column of text.\n".
                   "  /O3 = lang file (*.txt)   The file to contain the 3rd column of text.\n".
                   "  /O4 = lang file (*.txt)   The file to contain the 4th column of text.\n";
$FileHeader = "/* This file has been automatically generated by the PERL script\n".
              " * /50300PL/DEV/util/src/langsplit.pl.\n *\n".
              " *                    DO NOT EDIT THIS FILE !!\n *\n".
              " * Modifications should be carried out by changing the definition\n".
              " * files used to create the file. Use the ClearCase configuration\n".
              " * record to locate the source data definition files. \n */\n\n";

$BSlash = chr(92);
#-------------------------------------------------------------------------------
#  PUBLIC VARIABLES
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
#  SUBROUTINES
#-------------------------------------------------------------------------------
    sub ReadDefinitionFile;
	sub ProcessText;
#-------------------------------------------------------------------------------
#  Main function
#-------------------------------------------------------------------------------

    #---------------------------------------------------------------------------
    # Process command line arguments.
    #---------------------------------------------------------------------------

    for($Counter = 0; $Counter <= $#ARGV; $Counter++)
    {
        $_ = $ARGV[$Counter];

        if (m|/D|)
        {
            ReadDefinitionFile($ARGV[$Counter]);
        }
        elsif (m|/H|)
        {
            $HeaderFile = $ARGV[$Counter];
            $HeaderFile =~ s|/H=||;
        }
        elsif (m|/S|)
        {
            $SourceFile = $ARGV[$Counter];
            $SourceFile =~ s|/S=||;
        }
        elsif (m|/LANGS|)
        {
            $LanguagesToProcess = $ARGV[$Counter];
            $LanguagesToProcess =~ s|/LANGS=||;
        }
        elsif (m|/O1|)
        {
            $LanguageFile1 = $ARGV[$Counter];
            $LanguageFile1 =~ s|/O1=||;
        }
        elsif (m|/O2|)
        {
            $LanguageFile2 = $ARGV[$Counter];
            $LanguageFile2 =~ s|/O2=||;
        }
        elsif (m|/O3|)
        {
            $LanguageFile3 = $ARGV[$Counter];
            $LanguageFile3 =~ s|/O3=||;
        }
        elsif (m|/O4|)
        {
            $LanguageFile4 = $ARGV[$Counter];
            $LanguageFile4 =~ s|/O4=||;
        }
        elsif (m|/?|)
        {
            # Display help
            print $HelpText;

        }
        else
        {
            print "ARGUMENT ERROR \n";
        }
    }

    #print "Header file name : ".$HeaderFile."\n";
    #print "Source file name : ".$SourceFile."\n";
    #print "Number of languages : ".$LanguagesToProcess."\n";
    #print "Output language file 1 : ".$LanguageFile1."\n";
    #print "Output language file 2 : ".$LanguageFile2."\n";
    #print "Output language file 3 : ".$LanguageFile3."\n";
    #print "Output language file 4 : ".$LanguageFile4."\n";

    #---------------------------------------------------------------------------
    # Split the definition data into individual lines.
    #---------------------------------------------------------------------------

    @SplitRes = split /\n/, $DefinitionData;

    # For each line split into the components.

    @SplitLines = @SplitRes;

    foreach $SingleLine (@SplitLines)
    {
        $_ = $SingleLine;

        if (m/^#/)
        {
            # # directive line which should not be here. Produce an error message
            # because to continue and include everything may produce undesired results
            # due to the failure of the user to process the file using the 'C' preprocessor.
            #
            print ("\n ERROR : # found at the start of a line which indicates that\n");
            print ("         the file should be processed by the 'C' pre-processor.\n");
            print ("         Note that comments in the file should use the c++ style of\n");
            print ("         // at the start of every comment line.\n");
            exit(-1);
        }
        elsif (m/\/\//)
        {
            # Comment line to be ignored.
        }
        else
        {
            # Remove spaces except those in the string text.

            $QuoteFound = 0;

            @SplitRes = split //, $SingleLine;

            $SpaceFreeLine = "";

            if (@SplitRes > 0)
            {
                foreach $char (@SplitRes)
                {
                    $_ = $char;

                    if (m/ /)
                    {
                        if ($QuoteFound == 1)
                        {
                            $SpaceFreeLine = $SpaceFreeLine.$char;
                        }
                    }
                    elsif (m/\"/)
                    {
                        $SpaceFreeLine = $SpaceFreeLine.$char;
                        if ($QuoteFound == 1)
                        {
                            $QuoteFound = 0;
                        }
                        else
                        {
                            $QuoteFound = 1;
                        }
                    }
                    else
                    {
                        $SpaceFreeLine = $SpaceFreeLine.$char;
                    }
                    $Counter++;
                }

                @SplitRes = split /,/, $SpaceFreeLine;

                push @DefineList, $SplitRes[0];

                if (length($SplitRes[0]) > $MaxDefineLength)
                {
                    $MaxDefineLength = length($SplitRes[0]);
                }

                for ($LanguageCounter = 0; $LanguageCounter < 4; $LanguageCounter++)
                {
                    if ($LanguageCounter == 0)
                    {
                        push @LanguageOneList, $SplitRes[1 + $LanguageCounter];
                    }
                    if ($LanguageCounter == 1)
                    {
                        if ($LanguagesToProcess > 1)
                        {
                            push @LanguageTwoList, $SplitRes[1 + $LanguageCounter];
                        }
                     	else
                     	{
                     		push @LanguageTwoList, $SplitRes[1];
	                    }
                    }
                    elsif ($LanguageCounter == 2)
                    {
                        if ($LanguagesToProcess > 2)
                        {
                            push @LanguageThreeList, $SplitRes[1 + $LanguageCounter];
                        }
                     	else
                     	{
                     		push @LanguageThreeList, $SplitRes[1];
	                    }                    }
                    if ($LanguageCounter == 3)
                    {
                        if ($LanguagesToProcess > 3)
                        {
                            push @LanguageFourList, $SplitRes[1 + $LanguageCounter];
                        }
                     	else
                     	{
                     		push @LanguageFourList, $SplitRes[1];
	                    }
	              	}
                }

                push @StringTableNameList, $SplitRes[1 + $LanguagesToProcess];

                if (length($SplitRes[1 + $LanguagesToProcess]) > $MaxStringTableNameLength)
                {
                    $MaxStringTableNameLength = length($SplitRes[1 + $LanguagesToProcess]);
                }
            }
        }
    }

    #---------------------------------------------------------------------------
    # Build string tables.
    #---------------------------------------------------------------------------

    for ($Counter = 0; $Counter <= $#DefineList; $Counter++)
    {
        # Get the string table name associated with this string.

        $StringTableName = $StringTableNameList[$Counter];

        $_ = $StringTableName;

        if (!m/<NONE>/)
        {
            # Search the list of used references for this string table name.

            $Located = -1;

            for ($TableSearch = 0; $TableSearch <= $#UsedList; $TableSearch++)
            {
                $_ = $UsedList[$TableSearch];
                if ((m/$StringTableName/) && (length($_) == length($StringTableName)))
                {
                    $Located = $TableSearch;
                }
            }

            if ($Located == -1)
            {
                $UsedList[$#UsedList + 1] =  $StringTableName;

                $StringTable[$#StringTable + 1] =  "UINT32 ".$StringTableName."[] =";
                while (length($StringTable[$#StringTable]) < (length("UINT32 ") + $MaxStringTableNameLength + length("[] =")))
                {
                    $StringTable[$#StringTable] = $StringTable[$#StringTable]." ";
                }

                $StringTable[$#StringTable] = $StringTable[$#StringTable]."{ ".$DefineList[$Counter];
            }
            else
            {
                # Locate the section after the last carriage return character.
                #
                $_ = $StringTable[$Located];

                @SplitRes = split /\n/, $StringTable[$Located];

                if (length($SplitRes[$#SplitRes]) > 80)
                {
                    $StringTable[$Located] = $StringTable[$Located].",\n";
                    $AddSpaceCounter = 0;
                    while ($AddSpaceCounter < (length("UINT32 ") + $MaxStringTableNameLength + length("[] = {")))
                    {
                        $StringTable[$Located] = $StringTable[$Located]." ";
                        $AddSpaceCounter++;
                    }
                    $StringTable[$Located] = $StringTable[$Located].$DefineList[$Counter];
                }
                else
                {
                    $StringTable[$Located] = $StringTable[$Located].", ". $DefineList[$Counter];
                }
            }
        }
    }

    #---------------------------------------------------------------------------
    # Get the number of items in each line and replace the [] with [xx] where
    # xx is the number of items in the line.
    #---------------------------------------------------------------------------

    foreach $StringTableDef (@StringTable)
    {
        @SplitString = split /\,/, $StringTableDef;
        $Count = $#SplitString + 1;
        if ($Count < 10)
        {
            $StringTableDef =~ s/\{/  \{/;
            $StringTableDef =~ s/\n/\n   /g;
        }
        elsif ($Count < 100)
        {
            $StringTableDef =~ s/\{/ \{/;
            $StringTableDef =~ s/\n/\n   /g;
        }
        else
        {

            $StringTableDef =~ s/\n/\n   /g;
        }
        $StringTableDef =~ s/\[\]/\[$Count\]/;
    }

    #---------------------------------------------------------------------------
    # Generate files
    #---------------------------------------------------------------------------

    # generate the .h file.

    $ConstantCounter = 0;

    $HeaderFileTemp = ">".$HeaderFile;

    open HeaderFileHandle, $HeaderFileTemp;

    print HeaderFileHandle $FileHeader;

    print HeaderFileHandle "/* #pragma directives are used to locate string tables in the required\n * memory location.\n */\n\n";

    $HeaderFileNameCopy = $HeaderFile;

    $HeaderFileNameCopy =~ s/\./_/;

    $HeaderFileNameCopy = uc($HeaderFileNameCopy);

    print HeaderFileHandle "#ifndef ".$HeaderFileNameCopy."\n#define ".$HeaderFileNameCopy."\n\n";

    print HeaderFileHandle "#include \"types.h\"\n\n";

    foreach $StringTableName (@UsedList)
    {
        $PragmaLine =  "#pragma DATA_SECTION(".$StringTableName.", ";

        while (length($PragmaLine) < (length("#pragma DATA_SECTION(") + $MaxStringTableNameLength + length(", ")))
        {
            $PragmaLine = $PragmaLine." ";
        }
        $PragmaLine = $PragmaLine.'"sect_str")'."\n";

        print HeaderFileHandle $PragmaLine;

        $HeaderFileLine = "extern UINT32 ".$StringTableName."[];\n";

        $SearchText = "UINT32 ".$StringTableName;

        foreach $StringTableDef (@StringTable)
        {
            @SplitString = split /\[/, $StringTableDef;

            $_ = $SplitString[0];

            if ((m/$SearchText/) && (length($_) == length($SearchText)))
            {
                @SplitString = split /\[/, $StringTableDef;
                @NumString = split /\]/, $SplitString[1];
            }
        }
        $HeaderFileLine =~ s/\[\]/\[$NumString[0]\]/;

        print HeaderFileHandle $HeaderFileLine;
    }

    print HeaderFileHandle "\n/* #define directives. */\n\n";

    foreach $Define (@DefineList)
    {
        $HashDefineLine = "#define ".$Define;
        while (length($HashDefineLine) < (length("#define ") + $MaxDefineLength))
        {
            $HashDefineLine = $HashDefineLine." ";
        }
        $HashDefineLine = $HashDefineLine." \(".$ConstantCounter."\)\n";
        if ($ConstantCounter < 10)
        {
            $HashDefineLine =~ s/\(/   \(/;
        }
        elsif ($ConstantCounter < 100)
        {
            $HashDefineLine =~ s/\(/  \(/;
        }
        elsif ($ConstantCounter < 1000)
        {
            $HashDefineLine =~ s/\(/ \(/;
        }
        $ConstantCounter++;
        print HeaderFileHandle $HashDefineLine;
    }

    print HeaderFileHandle "\n#endif /* ".$HeaderFileNameCopy." */";


    print HeaderFileHandle "\n\n/*\n********************************************************************************\n";
    print HeaderFileHandle "** END OF FILE\n********************************************************************************\n";
    print HeaderFileHandle "*/\n";

    close HeaderFileHandle;

    # Write string text to output files.

	@LanguageList = @LanguageOneList;
    ProcessText($LanguageFile1, "E", $LanguagesToProcess, 1);
    @LanguageList = @LanguageTwoList;
    ProcessText($LanguageFile2, "F", $LanguagesToProcess, 2);
    @LanguageList = @LanguageThreeList;
    ProcessText($LanguageFile3, "G", $LanguagesToProcess, 3);
    @LanguageList = @LanguageFourList;
    ProcessText($LanguageFile4, "S", $LanguagesToProcess, 4);

    # Close the string table defintions with  }; and dump the information to the source file.

    $SourceFile = ">".$SourceFile;

    open SourceFileHandle, $SourceFile;

    print SourceFileHandle $FileHeader;

    print SourceFileHandle "#include ".'"'."types.h".'"'."\n";
    print SourceFileHandle "#include ".'"'.$HeaderFile.'"'."\n\n";

    foreach $StringTableDef (@StringTable)
    {
        $StringTableDef = $StringTableDef." }\;";
        print SourceFileHandle $StringTableDef."\n";
    }

    close SourceFileHandle;

    exit(0);

sub ReadDefinitionFile
{
    my $FileName = shift;

    $FileName =~ s|/D=||;

    open InputFileHandle, $FileName;

    while (eof(InputFileHandle) == 0)
    {
        read InputFileHandle, $DataFromFile, 25;
        $DefinitionData = join('',$DefinitionData, $DataFromFile);
    }

    close InputFileHandle;
}


sub ProcessText
{
    my $FileName = shift;
    my $LanguageFileChar = shift;
    my $languagesToProcess = shift;
    my $LanguageCounter = shift;

    $FileName = ">".$FileName;
    open OutputFileHandle, $FileName;
    $LineCounter = 0;

    foreach $String (@LanguageList)
    {
        $String =~ s/\"//g;
        # Search for \x or \d in the string.
        @SplitString = split //, $String;

        $MaxCounter = length($String);
        $Counter = 0;
        $NewString = "";

        while ($Counter < $MaxCounter)
        {
            $_ = $SplitString[$Counter];
            if (m/\x5c/)
            {
                # A \ character has been found - check what the next character is.

                $_ = $SplitString[$Counter + 1];

                if (m/\x5c/)
                {
                    # The user wants a \ character.
                    #
                    $NewString = $NewString.$BSlash;
                    $CharsExtracted = 2;
                }
                elsif(m/d/)
                {
                    # Decimal specified escape character.
                    # Get the next three characters from the string which
                    # must be numeric and convert to a special character.
                    #
                    if (($Counter + 4) >= $MaxCounter)
                    {
                        # Not enough characters remaining in the string after
                        # the \d specification.
                        #
                        print "Error. The ".$BSlash."d is not followed by enough characters.\n";
                        print "The faulty string is : ".$String."\n";
                        exit(-2);
                    }
                    else
                    {
                        $NumericString = substr $String, ($Counter + 2), 3;
                        $NewString = $NewString.(chr $NumericString);
                        $CharsExtracted = 5;
                    }
                }
                elsif(m/x/)
                {
                    # Hexadecimal specified escape character.
                    # Get the next pair of characters from the string which
                    # must be numeric and convert to a special character.
                    #
                    if (($Counter + 3) >= $MaxCounter)
                    {
                        # Not enough characters remaining in the string after
                        # the \x specification.
                        #
                        print "Error. The ".$BSlash."x is not followed by enough characters.\n";
                        print "The faulty string is : ".$String."\n";
                        exit(-3);
                    }
                    else
                    {
                        $NumericString = substr $String, ($Counter + 2), 2;
                        $NewString = $NewString. (chr (hex $NumericString));
                        $CharsExtracted = 4;
                    }
                }
                else
                {
                    print "Error. The ".$BSlash." character was not followed by either d, x or ".$BSlash."\n";
                    print "The faulty string is : ".$String."\n";
                    exit(-4);
                }
            }
            else
            {
                $NewString = $NewString.$SplitString[$Counter];
                $CharsExtracted = 1;
            }
            $Counter += $CharsExtracted;

        }
        while (length($NewString) < 16)
        {
            $NewString = $NewString." ";
        }
        if (length($NewString) > 16)
        {
            $NewString = substr($NewString, 0, 16);
        }

        if ($LanguagesToProcess < $LanguageCounter)
        {
            @SplitString = split //, $NewString;
            $SplitString[15] = $LanguageFileChar;
            $NewString = join(//, @SplitString);
        }

        print OutputFileHandle $NewString;
        $LineCounter = $LineCounter + 1;
        if ($LineCounter > 4096)
        {
            print "ERROR - Too many strings.\n\n";
        }
    }
    while ($LineCounter < 4096)
    {
        print OutputFileHandle "                ";
        $LineCounter++;
    }

    close OutputFileHandle;
}

#
#********************************************************************************
#** END OF FILE
#********************************************************************************
#

